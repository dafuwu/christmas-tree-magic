<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas Magic</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <script type="importmap">
    {
        "imports": {
            "three": "https://fastly.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://fastly.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://fastly.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
    </script>
    <style>
        :root { --gold: #d4af37; }
        body { margin: 0; background: #000; color: var(--gold); font-family: 'Cinzel', serif; overflow: hidden; }
        /* 优化后的加载层：3D准备好即消失 */
        #loader { position: fixed; inset: 0; background: #000; z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.8s; }
        .spinner { width: 50px; height: 50px; border: 2px solid #222; border-top: 2px solid var(--gold); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        
        #ui-overlay { position: absolute; inset: 0; pointer-events: none; z-index: 10; transition: opacity 0.5s; }
        h1 { position: absolute; top: 5%; width: 100%; text-align: center; font-size: clamp(24px, 8vw, 56px); background: linear-gradient(#fff, var(--gold)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 15px rgba(212,175,55,0.4)); margin: 0; }
        
        .controls { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); pointer-events: auto; text-align: center; }
        .btn-upload { border: 1px solid var(--gold); padding: 12px 25px; background: rgba(0,0,0,0.5); backdrop-filter: blur(10px); color: var(--gold); cursor: pointer; letter-spacing: 2px; transition: 0.3s; }
        .btn-upload:hover { background: rgba(212,175,55,0.2); box-shadow: 0 0 20px rgba(212,175,55,0.3); }
        .hint { margin-top: 10px; font-size: 12px; opacity: 0.7; font-family: sans-serif; }
        .ui-hidden { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>
    <div id="loader"><div class="spinner"></div><p>IGNITING HOLIDAY SPIRIT...</p></div>
    
    <div id="ui-overlay">
        <h1>Merry Christmas</h1>
        <div class="controls">
            <label class="btn-upload">ADD MEMORIES<input type="file" id="imgInp" hidden accept="image/*"></label>
            <div class="hint">Press 'H' to Hide | Use Hand Gestures</div>
        </div>
    </div>

    <video id="webcam" style="display:none" autoplay playsinline></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        const STATE = { mode: 'TREE', rotation: { x: 0, y: 0 }, focusIdx: -1 };
        let handLandmarker;

        // --- 1. 核心 3D 引擎 (找回视觉效果) ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 2, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 2.2;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 找回辉光 (Bloom)
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.45, 0.4, 0.7);
        composer.addPass(bloom);

        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // 灯光系统
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const p1 = new THREE.PointLight(0xffaa00, 1000); p1.position.set(10, 20, 10); scene.add(p1);

        // --- 2. 粒子与内容生成 ---
        const items = [];
        const boxGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const goldMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.8, roughness: 0.2 });
        const greenMat = new THREE.MeshStandardMaterial({ color: 0x0f4215, roughness: 0.8 });

        function createParticle(i, total) {
            const mesh = new THREE.Mesh(boxGeo, i % 3 === 0 ? goldMat : greenMat);
            const t = i / total;
            const r = 12 * (1 - t) + 0.5;
            const angle = t * 50 * Math.PI;
            
            const treePos = new THREE.Vector3(Math.cos(angle) * r, t * 30 - 15, Math.sin(angle) * r);
            const scatterPos = new THREE.Vector3().randomDirection().multiplyScalar(10 + Math.random() * 15);
            
            mesh.position.copy(treePos);
            mainGroup.add(mesh);
            items.push({ mesh, treePos, scatterPos, type: 'DECOR', rotVel: new THREE.Vector3(Math.random()*0.02, Math.random()*0.02, 0) });
        }

        for(let i=0; i<1500; i++) createParticle(i, 1500);

        // --- 3. 照片功能逻辑 ---
        window.addPhoto = (texture) => {
            const group = new THREE.Group();
            const photo = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 0.1), new THREE.MeshBasicMaterial({ map: texture }));
            const frame = new THREE.Mesh(new THREE.BoxGeometry(4.4, 4.4, 0.08), goldMat);
            group.add(photo, frame);
            
            const scatterPos = new THREE.Vector3().randomDirection().multiplyScalar(15);
            items.push({ mesh: group, treePos: new THREE.Vector3(0, 5, 0), scatterPos, type: 'PHOTO' });
            mainGroup.add(group);
            STATE.mode = 'TREE';
        };

        // --- 4. 异步 AI 加载 (不影响 3D 渲染) ---
        async function setupAI() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://fastly.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://fastly.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                document.getElementById('webcam').srcObject = stream;
                console.log("AI System Active");
            } catch (e) { console.warn("AI Init failed, using mouse fallback."); }
        }

        // --- 5. 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            
            // 处理手势识别
            if (handLandmarker && document.getElementById('webcam').readyState >= 2) {
                const results = handLandmarker.detectForVideo(document.getElementById('webcam'), performance.now());
                if (results.landmarks.length > 0) {
                    const lm = results.landmarks[0];
                    STATE.rotation.y = (lm[9].x - 0.5) * 2;
                    STATE.rotation.x = (lm[9].y - 0.5) * 1;
                    
                    // 手势逻辑：简化版判定
                    const d = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    if (d < 0.05) { STATE.mode = 'FOCUS'; if(STATE.focusIdx === -1) STATE.focusIdx = items.findIndex(n => n.type === 'PHOTO'); }
                    else if (lm[8].y > lm[0].y) { STATE.mode = 'TREE'; } // 握拳逻辑简化
                    else { STATE.mode = 'SCATTER'; }
                }
            }

            // 平滑旋转
            mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, STATE.rotation.y, 0.05);
            mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, STATE.rotation.x, 0.05);

            // 粒子运动机
            items.forEach((item, i) => {
                let target;
                if (STATE.mode === 'TREE') target = item.treePos;
                else if (STATE.mode === 'SCATTER') {
                    target = item.scatterPos;
                    item.mesh.rotation.x += item.rotVel.x;
                }
                else if (STATE.mode === 'FOCUS' && i === STATE.focusIdx) {
                    target = new THREE.Vector3(0, 0, 25);
                    item.mesh.lookAt(camera.position);
                } else {
                    target = item.scatterPos.clone().multiplyScalar(1.5);
                }
                item.mesh.position.lerp(target, 0.06);
            });

            composer.render();
        }

        // 启动
        setupAI();
        animate();
        document.getElementById('loader').style.opacity = '0';
        setTimeout(() => document.getElementById('loader').remove(), 800);

        // 输入处理
        document.getElementById('imgInp').onchange = (e) => {
            const reader = new FileReader();
            reader.onload = (ev) => new THREE.TextureLoader().load(ev.target.result, t => {
                t.colorSpace = THREE.SRGBColorSpace;
                window.addPhoto(t);
            });
            reader.readAsDataURL(e.target.files[0]);
        };
        window.onkeydown = (e) => { if(e.key.toLowerCase()==='h') document.getElementById('ui-overlay').classList.toggle('ui-hidden'); };
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
